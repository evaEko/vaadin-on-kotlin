[Index](index.html) | [Getting Started](gettingstarted.html) | [Guides](vok-guides.html)

# Accessing SQL databases with Vaadin-on-Kotlin

Vaadin-on-Kotlin provides first-class support for the following SQL databases out-of-the-box:

* [H2 Database](http://h2database.com) - a 100% Java database which can be quick-started as an in-memory
  database; perfect for writing tests for your app.
* [PostgreSQL](https://www.postgresql.org/)
* [MariaDB](https://mariadb.org/)
* [MySQL](https://www.mysql.com/)

All other SQL databases may or may not work. Care has been taken to only use the SQL92 syntax,
but we only test and officially support the four of the above-mentioned databases.

> *NoSQL Note*: Only SQL databases which provide appropriate JDBC drivers are currently supported.
There is no direct support for NoSQL databases, but you can easily integrate any NoSQL database with VoK.

> *Note for experienced Java developers*: Experienced Java developers will notice that VoK is *not* using JPA nor Hibernate to access the
database. The reason is that there are inherent issues with the abstraction that JPA
mandates - you can read more about the topic in the [Why Not JPA](http://mavi.logdown.com/posts/5771422) article.

## Basic CRUD ORM

The above scary acronym stands for inserting, querying and deleting rows from your database,
and mapping those rows into Kotlin objects so that they are easy to work with.

The "CRUD" stands for [Create, read, update and delete](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) -
the four basic operations performed on a collection of entities mapped to the database, such as a
collection of `Person`s.

The ORM stands for Object-Relational Mapping and stands for mapping database rows into Kotlin objects,
for easier use from within your application. VoK does not use JPA but instead features
a new, vastly simplified database access layer called `vok-orm`.

## About vok-orm

`vok-orm` is a very simple object-relational mapping library, built around the following ideas:

* Simplicity is the most valued property; working with plain SQL commands is preferred over having a type-safe
  query language.
* Kotlin objects merely capture JDBC `ResultSet` rows, by the means of invoking appropriate setters (based on the column name) via
  Java reflection.
* The entities are just plain objects: they do not track modifications as JPA entities do,
  they do not automatically store modified
  values back into the database. They are never runtime-enhanced and can be final.
* A switch from one type of database to another never happens. We understand that the programmer
  wants to exploit the full potential of the database, by writing SQLs tailored for that particular database.
  `vok-orm` should not attempt to generate SELECTs on behalf of the programmer (except for the very basic ones related to CRUD);
  instead it should simply allow SELECTs to be passed as Strings, and then map the result
  to an object of programmer's choosing.

Because of its simple design principles, `vok-orm` supports not just mapping tables to Kotlin classes,
but it allows mapping of any complex SELECT with joins and everything, even VIEWs, into Kotlin classes.
Naturally this allows you to use any SELECT inside of a Vaadin Grid component which is a
very powerful combination.

## Persisting simple objects into tables

Please read the [Usage examples](https://github.com/mvysny/vok-orm#usage-examples) chapter of
the `vok-orm` documentation on how to write Kotlin classes that correspond to a particular SQL database
table, and how to create rows in that particular database tables.

In this tutorial, we will modify the [vok-helloworld-app-v10](https://github.com/mvysny/vok-helloworld-app-v10) project:
it contains all moving parts but not much of an actual code which makes it ideal for experimenting. Just run
`git clone https://github.com/mvysny/vok-helloworld-app-v10` and open the project in your IDE and you're good to go.

> Note: please read the [Getting Started Guide](gettingstarted-v10.md) on information on these files.

Let us have a `Person` table with the following columns:

| Column | Type | Meaning
| ------ | ---- | ---------
| id | Long? | The primary key, automatically generated by the database, not null. The Kotlin type is nullable since we don't know the ID yet when the person is just being created.
| name | String | The full name of the person, not null.
| age | Int | The age, not null.
| dateOfBirth | LocalDate? | The date of birth, nullable.
| alive | Boolean | Whether the person is alive or deceased.
| maritalStatus | MaritalStatus? | The Marital status. Demoes binding to enum constants.
| modified | Instant? | When the record was last modified in the database

Let's first create a migration script which will prepare the database for us. Create a file
named `web/src/main/resources/db/migration/V01__CreatePerson.sql`, with the following DDL script, depending on your database:

The PostgreSQL DDL script which creates such table is simple:
```postgresql
create table Person (
    id bigserial primary key,
    name varchar(400) not null,
    age integer not null,
    dateOfBirth date,
    alive boolean not null,
    maritalStatus varchar(200),
    modified timestamp not null
)
```

The MySQL/MariaDB DDL script:
```mysql
create table Person (
    id bigint primary key auto_increment,
    name varchar(400) not null,
    age integer not null,
    dateOfBirth date,
    alive boolean not null,
    maritalStatus varchar(200),
    modified timestamp(3) not null
)
```

Finally, the H2 script:
```h2
create table Person (
    id bigint primary key auto_increment,
    name varchar not null,
    age integer not null,
    dateOfBirth date,
    alive boolean not null,
    maritalStatus varchar,
    modified timestamp not null
)
```

> *MaritalStatus Note*: We will store the enum name into the database, e.g. "Single", instead of
just ordinal value of the constant (e.g. 0). The ordinal is easy to accidentally change by the programmer,
e.g. by reordering the enum constants. The data would still load, but it would silently show incorrect
information which is disastrous.

Create the `web/src/main/kotlin/com/example/vok/Person.kt` file with the Kotlin class which will map to this table is as follows:

```kotlin
package com.example.vok

import com.github.vokorm.Dao
import com.github.vokorm.Entity
import java.time.Instant
import java.time.LocalDate

enum class MaritalStatus { Single, Married, Divorced, Widowed }

data class Person(
    override var id: Long? = null,
    var name: String = "",
    var age: Int = 0,
    var dateOfBirth: LocalDate? = null,
    var alive: Boolean = true,
    var maritalStatus: MaritalStatus? = null,
    var modified: Instant? = null
) : Entity<Long> {
    override fun save(validate: Boolean) {
        modified = Instant.now()
        super.save(validate)
    }

    companion object : Dao<Person>
}
```

By implementing the `Entity` interface the Kotlin class gains capability to create/update itself into
the database; by having the companion object to implement the `Dao` interface the Kotlin class
gains the lookup capabilities. You can paste the following example into the `WelcomeView.kt` file:

```kotlin
package com.example.vok

import com.github.vok.karibudsl.flow.*
import com.github.vokorm.*
import com.vaadin.flow.component.orderedlayout.VerticalLayout
import com.vaadin.flow.router.Route

@Route("")
class WelcomeView: VerticalLayout() {
    init {
        button("Demo") {
            onLeftClick {
                val person = Person(name = "John Doe", age = 42, alive = false, maritalStatus = MaritalStatus.Single)
                person.save()  // since ID is null, this will create the person and populate the ID
                println(Person.findAll())  // will print [Person(id=1, name=John Doe, age=42 etc)]
                println(Person.getById(person.id!!))  // will print Person(id=1, name=John Doe, age=42 etc)
                person.name = "Agent Smith"
                person.save()   // will update the person in the database, also updating the `modified` field
                println(Person.findById(25L)) // will print null since there is no such person yet
                Person.deleteAll()   // will delete all personnel
                Person.deleteById(42L)   // will delete a person with ID of 42
                println(Person.count()) // will print 0 since we deleted everything
                println(Person.findBy { "name = :name1 or name = :name2"("name1" to "John Doe", "name2" to "Agent Smith") })   // will print []
                Person.deleteBy { (Person::name eq "Agent Smith") }
                Person.getBy { "name = :name"("name" to "Agent Smith") }   // will fetch exactly one matching person, failing if there is no such person or there are more than one.
                Person.findSpecificBy { "name = :name"("name" to "Agent Smith") } // will fetch one matching person, failing if there are more than one. Returns null if there is none.
            }
        }
    }
}
```

To run the app, just type `./gradlew web:appRun` in your console, or run the `web` module in Tomcat. Then,
just browse [http://localhost:8080](http://localhost:8080) and click the "Demo" button.
For more information please read the [vok-orm documentation](https://github.com/mvysny/vok-orm).

> Finding Persons: If we want to load a list of persons from the database, the very important thing is to have a zero-arg constructor for the Person class.
This can be achieved either by providing default values for all parameters, or explicitly declaring the zero-arg constructor.
Otherwise the code will fail in runtime: Sql2o will try to construct a `Person` instance for every row returned, using
a zero-arg constructor.

## Forms

Forms allows the user to enter the values of a newly created record, or edit the values of
already existing ones. Validation is typically employed, to guide the user to enter
meaningful data.

We will use [Vaadin Binder](https://vaadin.com/docs/v10/flow/binding-data/tutorial-flow-components-binder.html) to bind form components to properties of the `Person` Kotlin class.
A source code of the form is shown below; just create a file named `web/src/main/kotlin/com/example/vok/PersonEditor.kt` with the following contents:

```kotlin
package com.example.vok

import com.github.vok.karibudsl.flow.*
import com.github.vokorm.findAll
import com.vaadin.flow.component.HasComponents
import com.vaadin.flow.component.orderedlayout.VerticalLayout

class PersonEditor : VerticalLayout() {
    private val binder = beanValidationBinder<Person>()
    var person: Person? = null
        set(value) {
            field = value
            if (value != null) binder.readBean(value)
        }

    init {
        isMargin = false
        textField("Name") {
            bind(binder).bind(Person::name)
        }
        textField("Age") {
            bind(binder).toInt().bind(Person::age)
        }
        datePicker("Date Of Birth") {
            bind(binder).bind(Person::dateOfBirth)
        }
        checkBox("Alive") {
            bind(binder).bind(Person::alive)
        }
        comboBox<MaritalStatus>("Marital Status") {
            setItems(*MaritalStatus.values())
            bind(binder).bind(Person::maritalStatus)
        }
        button("Save Person") {
            onLeftClick {
                val person = person!!
                if (binder.validate().isOk && binder.writeBeanIfValid(person)) {
                    person.save()
                    println(Person.findAll())
                }
            }
        }
    }
}

fun HasComponents.personEditor(block: PersonEditor.()->Unit = {}) = init(PersonEditor(), block)
```

This will create a form as a reusable component which we can then use in the `WelcomeView` as follows:

```kotlin
package com.example.vok

import com.vaadin.flow.component.orderedlayout.VerticalLayout
import com.vaadin.flow.router.Route

@Route("")
class WelcomeView: VerticalLayout() {
    init {
        personEditor {
            person = Person()
        }
    }
}
```

The form will allow you to create a new person, or edit an existing one. However,
the user can now enter invalid data, such as negative numbers for age etc.

We will use so-called JSR303 validation annotations, which will make the `beanValidationBinder` validate the bean for us. Edit the `Person` class
as follows:

```kotlin
package com.example.vok

import com.github.vokorm.*
import org.hibernate.validator.constraints.*
import java.time.*
import javax.validation.constraints.*

enum class MaritalStatus { Single, Married, Divorced, Widowed }

data class Person(
    override var id: Long? = null,
    @field:NotNull
    @field:Length(min = 2)
    var name: String = "",
    @field:Min(1)
    var age: Int = 0,
    @field:Past
    var dateOfBirth: LocalDate? = null,
    var alive: Boolean = true,
    var maritalStatus: MaritalStatus? = null,
    var modified: Instant? = null
) : Entity<Long> {
    override fun save(validate: Boolean) {
        modified = Instant.now()
        super.save(validate)
    }

    companion object : Dao<Person>
}
```

> *Important*: Make sure to attach those annotations to `field`! If you would just write `@Min(1)`, the annotation would be applied to the getter
instead to the field, and `beanValidationBinder` would ignore it.

Now, typing in incorrect values will make the field go red and show the validation errors; the "Save" button will also not create a Person
instance if the values are invalid.

## Using `vok-orm` with Vaadin Grid

Vaadin Grid is a very powerful component which allows you to show a lazy-loaded list of rows
on a web page. It allows the user to:

* efficiently scroll the list, lazy-loading more data as they are scrolled into the viewport,
* sorting by one or more columns (shift-click the caption to add sorting columns)
* filtering from code
* VoK provides means to auto-generate filter components and auto-populate them into the Grid,
  which provides you with a simple means to allow the user to filter as well.

You can find more information about how to use Vaadin Grid with Vaadin-on-Kotlin at the [Using Grids](grids-v10.md) guide page.

### Showing entities in Grid

We will start with the most basic Grid which will show the list of `Person`. By default the Grid shows all columns,
therefore we need to restrict the columns a bit:

```kotlin
package com.example.vok

import com.github.vok.framework.sql2o.vaadin.*
import com.github.vok.karibudsl.flow.*
import com.github.vokorm.db
import com.vaadin.flow.component.orderedlayout.VerticalLayout
import com.vaadin.flow.data.renderer.NativeButtonRenderer
import com.vaadin.flow.router.Route

@Route("")
class WelcomeView: VerticalLayout() {
    init {
        db {
            (5..30).forEach { Person(name = "p$it", age = it).save() }
        }
        setSizeFull()
        grid(dataProvider = Person.dataProvider) {
            setSizeFull()

            addColumnFor(Person::id)
            addColumnFor(Person::name)
            addColumnFor(Person::age)
            addColumnFor(Person::dateOfBirth)
            addColumnFor(Person::maritalStatus)
            addColumnFor(Person::alive)
            // example of a custom renderer which converts value to a displayable string.
            addColumnFor(Person::modified, converter = { it.toString() })
            addColumn(NativeButtonRenderer<Person>("Delete", { item -> item.delete(); this@grid.refresh() }))
        }
    }
}
```

This is a full-blown Grid with lazy-loading and SQL-based (so not in-memory) sorting working out-of-the-box. Adding the possibility
for the user to filter on the contents of the Grid is really easy, just add the following call, as the last
line into the `grid { ...  }` block:

```kotlin
appendHeaderRow().generateFilterComponents(this, Person::class)
```

TBD
